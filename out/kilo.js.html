<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: kilo.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: kilo.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const readline = require('readline');
const pkg = require('../package');
const fs = require('fs');
const os = require('os');
const KILO_TAB_STOP = 8;
const MULTI_BYTE = 2;
/**
 * @classdesc This is Kilo class
 * @constructor
 */
class Kilo {
  /**
   * @constructor
   * @desc 
   * &lt;ul>
   * &lt;li>initialize all E&lt;/li>
   * &lt;li>this.buf = ''&lt;/li>
   * &lt;li>set timeout after 5 sec statusmsg will be dismissed&lt;/li>
   * &lt;/ul>
   */
  constructor(argv) {
    readline.emitKeypressEvents(process.stdin);
    this.E = {
      cx: 0,
      rx: 0,
      cy: 0,
      erow: [],
      render: [],
      rowoff: 0,
      coloff: 0,
      screenrows: process.stdout.rows - 2,
      screencols: process.stdout.columns,
      filename: argv &amp;&amp; argv.length > 0 ? argv[0] : undefined,
      statusmsg: "HELP: Ctrl-Q = quit"
    };
    setTimeout(() => this.E.statusmsg = "", 5000);
    this.abuf = '';
  }

  /**
   * exit if some error happened
   * @param {string} e - dying message
   * @param {int} status - exit status default: 1
   *
   */
  die(e,status){
    this.abuf = '';
    process.stdout.write("\x1b[2J", 4);
    process.stdout.write("\x1b[H", 3);
    this.disableRawMode();
    console.error(e);
    process.exit(status || 1);
  }

  /**
   * set TTY rowmode
   *
   */
  enableRawMode() {
    if (process.stdin.isTTY) {
      process.stdin.setRawMode(true);
    }
  }

  /**
   * clear TTY rowmode
   *
   */
  disableRawMode() {
    if (process.stdin.isTTY) {
      process.stdin.setRawMode(false);
      process.stdin.resume();
    }
  }

  /**
   * open this.E.filename
   * 
   * @desc 
   * &lt;ul>
   * &lt;li>set erow // editor low&lt;/li>
   * &lt;li>set render // for rendering low&lt;/li>
   * &lt;/ul>
   * @throws {Error} - ENOENT: no such file or directory, open this.filename
   *
   */
  editorOpen() {
    this.E.erow = fs.readFileSync(this.E.filename, 'utf8').trim().split(os.EOL);
    this.E.render = this.E.erow.map((str) => str.replace(/\t/g," ".repeat(KILO_TAB_STOP)));
  }

  /**
   * calculate erow cx -> rx
   * 
   * @desc 
   * &lt;ul>
   * &lt;li>- treat \t&lt;/li>
   * &lt;li>- treat unicode multibyte characters&lt;/li>
   * &lt;/ul>
   * @returns {int} rx - rx position
   * @todo handle multibyte properly 
   */
  editorRowCxToRx(row,  cx) {
    let rx = 0;
    let  j;
    const chars = row.match(/./ug);
    for (j = 0; j &lt; cx; j++) {
      if (chars[j] == '\t')
        rx += (KILO_TAB_STOP - 1) - (rx % KILO_TAB_STOP);
      if (/%[89ABab]/g.test(encodeURIComponent(chars[j])))
        rx += (MULTI_BYTE - 1) - (rx % MULTI_BYTE);
      rx++;
    }
    return rx;
  }

  /**
   * calculate scrolling offset
   *
   * @desc 
   * &lt;ul>
   * &lt;li>handle rowoff&lt;/li>
   * &lt;li>handle coloff&lt;/li>
   * &lt;/ul>
   *
   */
  editorScroll() {
    this.E.rx = 0;
    if (this.E.cy &lt; this.E.erow.length) {
      this.E.rx = this.editorRowCxToRx(this.E.erow[this.E.cy], this.E.cx);
    }
    if (this.E.cy &lt; this.E.rowoff) {
      this.E.rowoff = this.E.cy;
    }
    if (this.E.cy >= this.E.rowoff + this.E.screenrows) {
      this.E.rowoff = this.E.cy - this.E.screenrows + 1;
    }
    if (this.E.rx &lt; this.E.coloff) {
      this.E.coloff = this.E.rx;
    }
    if (this.E.rx >= this.E.coloff + this.E.screencols) {
      this.E.coloff = this.E.rx - this.E.screencols + 1;
    }
  }

  /**
   * refresh screen
   *
   * @desc 
   * &lt;ul>
   * &lt;li>hide cursor&lt;/li>
   * &lt;li>draw rows (file contents)&lt;/li>
   * &lt;li>draw status bar&lt;/li>
   * &lt;li>draw message bar&lt;/li>
   * &lt;li>set cursor proper position (rx,cy)&lt;/li>
   * &lt;li>show cursor&lt;/li>
   * &lt;/ul>
   *
   */
  editorRefreshScreen() {
    this.editorScroll();
    this.abuf += "\x1b[?25l";
    this.abuf += "\x1b[H";
    this.editorDrawRows();
    this.editorDrawStatusBar();
    this.editorDrawMessageBar();
    this.abuf += `\x1b[${(this.E.cy - this.E.rowoff) + 1};${(this.E.rx - this.E.coloff) + 1}H`; //cursor
    this.abuf += "\x1b[?25h";
    process.stdout.write(this.abuf, this.abuf.length);
    this.abuf = '';
  }

  /**
   * handle key action
   * @param {string} str - captured str (not used in this class)
   * @param {Object} key - captured key information
   */
  editorReadKey(str, key) {
    switch (key.name) {
      case 'q':
        if (key.ctrl) {
          this.die("BYE",0);
        }
        break;
      case 'home':
        this.E.cx = 0;
        break;
      case 'end':
        {
          if (this.E.cy &lt; this.E.erow.length) this.E.cx = this.E.erow[this.E.cy].length;
        }
        break;
      case 'pageup':
        this.E.cy = this.E.rowoff;
      case 'pagedown':
        {
          if (key.name == 'pagedown') {
            this.E.cy = this.E.rowoff + this.E.screenrows - 1;
            if (this.E.cy > this.E.erow.length) this.E.cy = this.E.erow.length;
          }
          let times = this.E.screenrows;
          while (times--) this.editorMoveCursor(key.name == 'pageup' ? 'up' : 'down');
        }
        break;
      case 'h':
      case 'left':
      case 'l':
      case 'right':
      case 'k':
      case 'up':
      case 'j':
      case 'down':
        this.editorMoveCursor(key.name);
    }
    this.editorRefreshScreen();
  }

  /**
   * handle key action for cursor movement
   * @param {string} name - key.name
   */
  editorMoveCursor(name) {
    let row = (this.E.cy >= this.E.erow.length) ? undefined : this.E.erow[this.E.cy];
    switch (name) {
      case 'h':
      case 'left':
        if (this.E.cx > 0) {
          this.E.cx--;
        } else if (this.E.cy > 0) {
          this.E.cy--;
          this.E.cx = this.E.erow[this.E.cy].length;
        }
        break;
      case 'l':
      case 'right':
        if (row &amp;&amp; this.E.cx &lt; row.length) {
          this.E.cx++;
        } else if (row !== undefined &amp;&amp; this.E.cx == row.length) {
          this.E.cy++;
          this.E.cx = 0;
        }
        break;
      case 'k':
      case 'up':
        if (this.E.cy > 0) this.E.cy--;
        break;
      case 'j':
      case 'down':
        if (this.E.cy &lt; this.E.erow.length) this.E.cy++;
        break;
    }
    row = (this.E.cy >= this.E.erow.length) ? undefined : this.E.erow[this.E.cy];
    const rowlen = row ? row.length : 0;
    if (this.E.cx > rowlen) {
      this.E.cx = rowlen;
    }
  }

  /**
   * drow status bar
   */
  editorDrawStatusBar() {
    this.abuf += "\x1b[7m";
    const status = `${this.E.filename ? this.E.filename : "[No Name]"} - ${this.E.erow.length} lines`;
    let len = status.length;
    const rstatus = `${this.E.cy + 1}/${this.E.erow.length}`;
    if (len > this.E.screencols) len = this.E.screencols;
    this.abuf += status.substring(0, len);
    while (len &lt; this.E.screencols) {
      if (this.E.screencols - len == rstatus.length) {
        this.abuf += rstatus;
        break;
      } else {
        this.abuf += " ";
        len++;
      }
    }
    this.abuf += "\x1b[m";
    this.abuf += os.EOL;
  }

  /**
   * drow message bar
   */
  editorDrawMessageBar() {
    this.abuf += "\x1b[K";
    this.abuf += this.E.statusmsg.length > this.E.screencols ? this.E.statusmsg.substring(0, this.E.screencols) : this.E.statusmsg;
  }

  /**
   * drow file contents
   */
  editorDrawRows() {
    for (let y = 0; y &lt; this.E.screenrows; y++) {
      let filerow = y + this.E.rowoff;
      if (filerow >= this.E.erow.length) {
        if (this.E.erow.length == 0 &amp;&amp; y == parseInt(this.E.screenrows / 3)) {
          const welcome = `Kilo editor -- version ${pkg.version}`;
          let welcomlen = welcome.length;
          if (welcomlen > this.E.screencols) welcomlen = this.E.screencols;
          let padding = parseInt((this.E.screencols - welcomlen) / 2);
          if (padding > 0) {
            this.abuf += "~";
            padding--;
          }
          while (padding-- > 0) this.abuf += " ";
          this.abuf += welcome;
        } else {
          this.abuf += "~";
        }
      } else {
        let len = this.E.render[filerow].length - this.E.coloff;
        if (len &lt; 0) len = 0;
        if (len > this.E.screencols) len = this.E.screencols;
        this.abuf += this.E.render[filerow].substring(this.E.coloff, this.E.coloff + len);
      }
      this.abuf += "\x1b[K";
      this.abuf += os.EOL;
    }
  }

  /**
   * main function
   */
  main() {
    try{
      this.enableRawMode();
      if (this.E.filename !== undefined) {
        this.editorOpen();
      }
      this.editorRefreshScreen();
      process.stdin.on('keypress', this.editorReadKey.bind(this));
    } catch(e) {
      this.die(e);
    }
  }
}
if (typeof module !== 'undefined' &amp;&amp; typeof module.exports !== 'undefined') {
  module.exports = Kilo;
} else {
  window.Kilo = Kilo;
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Kilo.html">Kilo</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.6</a> on Sat Oct 31 2020 22:01:04 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
