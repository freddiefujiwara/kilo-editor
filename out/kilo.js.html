<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: kilo.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: kilo.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";
const readline = require("readline");
const pkg = require("../package");
const fs = require("fs");
const os = require("os");
const KILO_TAB_STOP = 8;
const MULTI_BYTE = 2;
const STATUS_MSG_TIMEOUT = 5000;
const SEARCHABLE_CHARS = /^[\ta-z0-9!"#$%&amp;'()*+,./:;&lt;=>?@[\]\\ ^_`{|}~-]$/ui;
const MODE = { NORMAL: 0, INSERT: 1, SEARCH: 2, COMMAND: 3 };

/**
 * @classdesc This is Kilo class
 * @constructor
 */
class Kilo {

    /**
     * JavaScript port for kilo.c
     * @param {Array} argv process.argv
     * @constructor
     * &lt;ul>
     * &lt;li>initialize all E&lt;/li>
     * &lt;li>this.buf = ''&lt;/li>
     * &lt;li>set timeout after 5 sec statusmsg will be dismissed&lt;/li>
     * &lt;/ul>
     */
    constructor(argv) {
        readline.emitKeypressEvents(process.stdin);
        this.E = { // editorConfig
            cx: 0, // cursor position x
            cy: 0, // cursor position y
            rx: 0, // rendered cursor position x
            rowoff: 0, // row offset
            coloff: 0, // column offset
            erow: [], // editing row
            render: [], // rendering row
            screenrows: process.stdout.rows - 2, // screen size(rows) -  status bar and message bar
            screencols: process.stdout.columns, // screen size(columns)
            statusmsg: "", // status message
            dirty: 0 // modified flag
        };
        if (argv &amp;&amp; argv.length > 0) {
            this.E.filename = argv[0];
        }
        this.editorSetStatusMessage("HELP): k:up/j:down/l:right/h:left | i:insert | /:search | :w save/ :q quit/ :wq save &amp; quit");
        this._saveStateForUndo();
        this.mode = MODE.NORMAL; // mode;
        this.sx = [];// searched cursor position x
        this.sy = []; // searched cursor position y
        this.si = 0; // searched index
        this.abuf = ""; // for draw
        this.scbuf = ""; // for search
        this.ybuf = ""; // for yank
        this.prev = ""; // for 2 setp commnd ex) dd yy
    }

    /**
     * exit if some error happened
     * @param {string} e dying message
     * @param {int} status exit status default: 1
     * @returns {void}
     *
     */
    die(e, status) {
        this.abuf = "";
        process.stdout.cursorTo(0, 0);
        process.stdout.clearScreenDown();
        Kilo.disableRawMode();
        console.error(e);
        process.exit(typeof status === "undefined" ? 1 : parseInt(status, 10));
    }

    /**
     * set TTY rowmode
     * @returns {void}
     *
     *
     */
    static enableRawMode() {
        if (process.stdin.isTTY) {
            process.stdin.setRawMode(true);
        }
    }

    /**
     * clear TTY rowmode
     * @returns {void}
     *
     *
     */
    static disableRawMode() {
        if (process.stdin.isTTY) {
            process.stdin.setRawMode(false);
            process.stdin.resume();
        }
    }

    /**
     * open this.E.filename
     * @description
     * &lt;ul>
     * &lt;li>set erow // editor low&lt;/li>
     * &lt;li>set render // for rendering low&lt;/li>
     * &lt;/ul>
     * @throws {Error} - ENOENT: no such file or directory, open this.filename
     * @returns {void}
     *
     */
    editorOpen() {
        this.E.erow = fs.readFileSync(this.E.filename, "utf8").trim().split(os.EOL);
        this.editorUpdateRow();
        this.E.dirty = 0;
    }

    /**
     * save to this.E.filename
     * @returns {void}
     */
    editorSave() {
        const erows = this.E.erow.join(os.EOL);

        try {
            fs.writeFileSync(this.E.filename, erows);
            this.editorSetStatusMessage(`${erows.length} bytes written to disk`);
            this.E.dirty = 0;
        } catch (e) {
            this.editorSetStatusMessage(`${e.name}:${e.message}`);
        }
    }

    /**
     * show status message in 5 secs
     * @param {string} message status message
     * @returns {void}
     */
    editorSetStatusMessage(message) {
        this.E.statusmsg = message;
        setTimeout(() => {
            this.E.statusmsg = "";
        }, STATUS_MSG_TIMEOUT);
    }

    /**
     * update render
     * @todo handle multibyte properly
     * @returns {void}
     */
    editorUpdateRow() {
        this.E.render = this.E.erow.map(str => str.replace(/\t/ug, " ".repeat(KILO_TAB_STOP)));
    }

    /**
     * insert single char
     * @param {char} c char which will be inserted
     * @todo handle multibyte properly
     * @returns {void}
     */
    editorInsertChar(c) {
        this._saveStateForUndo();
        if (this.E.cy === this.E.erow.length) {
            this.editorInsertRow();
        }
        let pos = this.E.cx;
        const row = this.E.erow[this.E.cy];

        if (this.E.cx &lt; 0 || this.E.cx > row.length) {
            pos = row.length;
        }

        this.E.erow[this.E.cy] = `${row.slice(0, pos)}${c}${row.slice(pos)}`;
        this.editorUpdateRow();
        this.editorMoveCursor("right");
        this.E.dirty++;
    }

    /**
     * insert one row
     * @param {string} insert string which will be inserted
     * @todo handle multibyte properly
     * @returns {void}
     */
    editorInsertRow(insert) {
        this._saveStateForUndo();
        this.E.erow.splice(this.E.cy, 0, insert || "");
        this.E.dirty++;
    }

    /**
     * delete single char
     * @todo handle multibyte properly
     * @returns {void}
     */
    editorDelChar() {
        if (this.E.erow.length === 0) {
            return;
        }
        if (this.E.erow.length &lt;= this.E.cy) {
            return;
        }
        const row = this.E.erow[this.E.cy];
        const newRow = `${row.slice(0, this.E.cx)}${row.slice(this.E.cx + 1)}`;

        if (newRow.length > 0) {
            this.E.erow[this.E.cy] = newRow;
        } else {
            this.E.erow.splice(this.E.cy, 1);
            if (this.E.erow.length > 0 &amp;&amp; this.E.cy > 0) {
                this.E.cy--;
            }
        }
        this.editorUpdateRow();
        this.E.dirty++;
    }

    /**
     * calculate erow cx -> rx
     * @param {string} row target row
     * @param {int} cx  - target cx
     * @description
     * &lt;ul>
     * &lt;li>- treat \t&lt;/li>
     * &lt;li>- treat unicode multibyte characters&lt;/li>
     * &lt;/ul>
     * @returns {int} rx - rx position
     * @todo handle multibyte properly
     */
    static editorRowCxToRx(row, cx) {
        const chars = row.match(/./ug);
        let rx = 0;

        for (let j = 0; j &lt; cx; j++) {
            if (chars[j] === "\t") { // tab
                rx += (KILO_TAB_STOP - 1) - (rx % KILO_TAB_STOP);
            }
            if (/%[89ABab]/ug.test(encodeURIComponent(chars[j]))) { // multibyte
                rx += (MULTI_BYTE - 1) - (rx % MULTI_BYTE);
            }
            rx++;
        }
        return rx;
    }

    /**
     * calculate scrolling offset
     * @description
     * &lt;ul>
     * &lt;li>handle rowoff&lt;/li>
     * &lt;li>handle coloff&lt;/li>
     * &lt;/ul>
     * @returns {void}
     *
     */
    editorScroll() {
        this.E.rx = 0;
        if (this.E.cy &lt; this.E.erow.length) { // calculate rx if cursor is in the file
            this.E.rx = Kilo.editorRowCxToRx(this.E.erow[this.E.cy], this.E.cx);
        }
        if (this.E.cy &lt; this.E.rowoff) { // move cy to the top of the window if cy is off the top of the scrolling window
            this.E.rowoff = this.E.cy;
        }
        if (this.E.cy >= this.E.rowoff + this.E.screenrows) { // move cy to the bottom of the window if cy is off the bottom of the scrolling window
            this.E.rowoff = this.E.cy - this.E.screenrows + 1;
        }
        if (this.E.rx &lt; this.E.coloff) { // move rx to the left of the window if rx is off the left of the scrolling window
            this.E.coloff = this.E.rx;
        }
        if (this.E.rx >= this.E.coloff + this.E.screencols) { // move rx to the right of the window if rx is off the right of the scrolling window
            this.E.coloff = this.E.rx - this.E.screencols + 1;
        }
    }

    /**
     * refresh screen
     * @description
     * &lt;ul>
     * &lt;li>hide cursor&lt;/li>
     * &lt;li>draw rows (file contents)&lt;/li>
     * &lt;li>draw status bar&lt;/li>
     * &lt;li>draw message bar&lt;/li>
     * &lt;li>set cursor proper position (rx,cy)&lt;/li>
     * &lt;li>show cursor&lt;/li>
     * &lt;/ul>
     * @returns {void}
     *
     */
    editorRefreshScreen() {
        this.editorScroll();
        this.abuf += "\x1b[?25l"; // hide cursor
        this.abuf += "\x1b[H"; // set ursor 0,0
        this.editorDrawRows();
        this.editorDrawStatusBar();
        this.editorDrawMessageBar();
        this.abuf += `\x1b[${(this.E.cy - this.E.rowoff) + 1};${(this.E.rx - this.E.coloff) + 1}H`; // set cursor position
        this.abuf += "\x1b[?25h"; // show cursor
        process.stdout.write(this.abuf);
        this.abuf = "";
    }

    /**
     * handle key action
     * @param {string} str captured str (not used in this class)
     * @param {Object} key captured key information
     * @throws {Error}
     * @returns {void}
     */
    editorReadKey(str, key) {
        try {
            if (key.meta) {
                this.mode = MODE.NORMAL;
            } else {
                let command = "";

                switch (this.mode) {
                    case MODE.NORMAL:
                        command = this._handleNormalMode(key);
                        break;
                    case MODE.INSERT:
                        command = this._handleInsertMode(key);
                        break;
                    case MODE.SEARCH:
                        command = this._handleSearchMode(key);
                        break;
                    case MODE.COMMAND:
                        command = this._handleCommandMode(key);
                        if (command === null) {
                            return;
                        }
                        break;
                    default:
                        break;
                }
                this.editorSetStatusMessage(`${command} (${this.E.cx}:${this.E.cy})  -- ${Object.keys(MODE)[this.mode]} --`);
            }
            this.editorRefreshScreen();
        } catch (e) {
            this.die(e);
        }
    }

    /**
     * handle normal mode key action
     * @param {Object} key captured key information
     * @returns {string} command status message
     */
    _handleNormalMode(key) {
        let command = "";

        if (typeof key.name === "undefined") {
            switch (key.sequence) {
                case "$":
                    this.editorMoveCursor("end");
                    break;
                case "^":
                    this.editorMoveCursor("home");
                    break;
                case "/":
                    this.mode = MODE.SEARCH;
                    this.sx = [];
                    this.sy = [];
                    this.scbuf = "";
                    this.si = 0;
                    command = `/${this.scbuf}`;
                    break;
                case ":":
                    this.mode = MODE.COMMAND;
                    this.scbuf = "";
                    command = `:${this.scbuf}`;
                    break;
                default:
                    break;
            }
        } else {
            this.editorMoveCursor(key.name, key.sequence);
        }
        this.prev = key.name;
        return command;
    }

    /**
     * handle insert mode key action
     * @param {Object} key captured key information
     * @returns {string} command status message
     */
    _handleInsertMode(key) {
        if (SEARCHABLE_CHARS.test(key.sequence)) {
            this.editorInsertChar(key.sequence);
        } else if (key.name === "return") {
            this.editorInsertRow();
            this.editorMoveCursor("home");
            this.editorMoveCursor("down");
            this.editorUpdateRow();
        } else {
            this.editorMoveCursor(key.name, key.sequence);
        }
        return "";
    }

    /**
     * handle search mode key action
     * @param {Object} key captured key information
     * @returns {string} command status message
     */
    _handleSearchMode(key) {
        switch (key.name) {
            case "return":
                this.mode = MODE.NORMAL;
                // fall through
            case "backspace":
            case "delete":
                this.scbuf = "";
                break;
            case "right":
            case "up":
                this.si = (this.si + 1) % this.sx.length;
                break;
            case "left":
            case "down":
                this.si--;
                if (this.si &lt; 0) {
                    this.si = this.sx.length - 1;
                }
                break;
            default:
                if (SEARCHABLE_CHARS.test(key.sequence)) {
                    this.scbuf += key.sequence;
                    this.sx = [];
                    this.sy = [];
                    this.si = 0;
                    this.E.erow.forEach((r, y) => {
                        const matches = [...r.matchAll(new RegExp(this.scbuf.replace(/[.*+?^${}()|[\]\\]/ug, "\\$&amp;"), "ugi"))];

                        matches.forEach(m => {
                            this.sx.push(m.index);
                            this.sy.push(y);
                        });
                    });
                }
        }
        if (this.sx.length > this.si) {
            this.E.cx = this.sx[this.si];
            this.E.cy = this.sy[this.si];
        }
        return `/${this.scbuf} (${this.sx.length}) found &lt;-prev:next->)`;
    }

    /**
     * handle command mode key action
     * @param {Object} key captured key information
     * @returns {string} command status message
     */
    _handleCommandMode(key) {
        if (key.name === "return") {
            switch (this.scbuf) {
                case "w":
                    this.editorSave();
                    this.editorRefreshScreen();
                    this.scbuf = "";
                    return null;
                case "wq":
                    this.editorSave();
                    this.editorRefreshScreen();
                    this.die("BYE", 0);
                    this.scbuf = "";
                    return null;
                case "q":
                    this.die("BYE", 0);
                    this.scbuf = "";
                    return null;
                default:
                    break;
            }
            this.scbuf = "";
            return `:${this.scbuf}`;
        } else if (key.name === "delete" || key.name === "backspace") {
            if (this.scbuf.length &lt;= 0) {
                this.mode = MODE.NORMAL;
                return "";
            }
            this.scbuf = this.scbuf.slice(0, -1);
            return `:${this.scbuf}`;
        } else if (SEARCHABLE_CHARS.test(key.sequence)) {
            this.scbuf += key.sequence;
            return `:${this.scbuf}`;
        }
        return `:${this.scbuf}`;
    }

    /**
     * resize terminal
     * @returns {void}
     */
    editorResize() {
        this.E.screenrows = process.stdout.rows - 2; // status bar and message bar
        this.E.screencols = process.stdout.columns;
        this.editorRefreshScreen();
    }

    /**
     * handle key action for cursor movement
     * @param {string} name key.name
     * @param {string} sequence key.sequence
     * @returns {void}
     */
    editorMoveCursor(name, sequence) {
        const row = (this.E.cy >= this.E.erow.length) ? false : this.E.erow[this.E.cy];

        switch (name) {
            case "home":
            case "0":
                this.E.cx = 0;
                break;
            case "end":
                if (this.E.cy &lt; this.E.erow.length) {
                    this.E.cx = this.E.erow[this.E.cy].length;
                }
                break;
            case "backspace":
            case "delete":
            case "x":
                this._handleDeleteChar(name, row);
                break;
            case "a":
                this.editorMoveCursor("right");
                // fall through
            case "insert":
            case "i":
                this._handleEnterInsertMode();
                break;
            case "o":
                this._handleOpenLine(sequence);
                break;
            case "u":
                this._handleUndo();
                break;
            case "y":
                this._handleYank(row);
                break;
            case "g":
                this._handleJumpToLine(sequence);
                break;
            case "d":
                this._handleDeleteRow(row, sequence);
                break;
            case "p":
                this._handlePaste();
                break;
            case "pageup":
            case "pagedown":
                this._handlePageJump(name);
                break;
            case "h":
            case "left":
                this._moveLeft();
                break;
            case "l":
            case "right":
                this._moveRight(row);
                break;
            case "k":
            case "up":
                this._moveUp();
                break;
            case "j":
            case "down":
            case "return":
                this._moveDown();
                break;
            default:
                break;
        }
        const rowlen = (this.E.cy >= this.E.erow.length) ? 0 : this.E.erow[this.E.cy].length;

        if (this.E.cx > rowlen) {
            this.E.cx = rowlen;
        }
    }

    /**
     * save current state for undo
     * @returns {void}
     */
    _saveStateForUndo() {
        this.backup = JSON.stringify(this.E);
    }

    /**
     * handle undo action
     * @returns {void}
     */
    _handleUndo() {
        if (this.backup === "") {
            return;
        }
        const backupu = this.E;

        this.E = JSON.parse(this.backup);
        this.backup = JSON.stringify(backupu);
    }

    /**
     * handle yank action
     * @param {string|boolean} row current row content
     * @returns {void}
     */
    _handleYank(row) {
        if (row !== false &amp;&amp; this.prev === "y") {
            this.ybuf = row;
        }
    }

    /**
     * handle paste action
     * @returns {void}
     */
    _handlePaste() {
        this.editorMoveCursor("down");
        this.editorInsertRow(this.ybuf);
        this.editorUpdateRow();
    }

    /**
     * handle delete char action
     * @param {string} name key name
     * @param {string|boolean} row current row content
     * @returns {void}
     */
    _handleDeleteChar(name, row) {
        if (name === "backspace") {
            this._moveLeft();
        }
        this._saveStateForUndo();
        this.editorDelChar();
        if (row !== false &amp;&amp; row.length === 0) {
            this._moveDown();
        }
    }

    /**
     * handle enter insert mode action
     * @returns {void}
     */
    _handleEnterInsertMode() {
        this.mode = MODE.INSERT;
        this.editorSetStatusMessage(`(${this.E.cx}:${this.E.cy}) - -- INSERT --`);
        this.editorRefreshScreen();
    }

    /**
     * handle open line action
     * @param {string} sequence key sequence
     * @returns {void}
     */
    _handleOpenLine(sequence) {
        if (sequence === "O") {
            this.editorInsertRow();
        } else {
            this._moveDown();
            this.editorInsertRow();
        }
        this.E.cx = 0;
        this.editorUpdateRow();
        this.mode = MODE.INSERT;
    }

    /**
     * handle jump to line action (gg or G)
     * @param {string} sequence key sequence
     * @returns {void}
     */
    _handleJumpToLine(sequence) {
        if (sequence === "G") {
            this.E.cx = 0;
            this.E.cy = this.E.erow.length > 0 ? this.E.erow.length - 1 : 0;
        } else if (this.prev === "g") {
            this.E.cx = 0;
            this.E.cy = 0;
        }
    }

    /**
     * handle delete row action (dd or D)
     * @param {string|boolean} row current row content
     * @param {string} sequence key sequence
     * @returns {void}
     */
    _handleDeleteRow(row, sequence) {
        if (row !== false) {
            if (this.prev === "d") {
                this._saveStateForUndo();
                this.E.cx = 0;
                this.ybuf = row;
                [...Array(row.length)].forEach(() => this.editorDelChar());
            } else if (sequence === "D") {
                this._saveStateForUndo();
                [...Array(row.length - this.E.cx)].forEach(() => this.editorDelChar());
            }
        }
    }

    /**
     * handle page jump action
     * @param {string} name key name
     * @returns {void}
     */
    _handlePageJump(name) {
        if (name === "pageup") {
            this.E.cy = this.E.rowoff;
        } else {
            this.E.cy = this.E.rowoff + this.E.screenrows - 1;
            if (this.E.cy > this.E.erow.length) {
                this.E.cy = this.E.erow.length;
            }
        }
        [...Array(this.E.screenrows)].forEach(() => this.editorMoveCursor(name === "pageup" ? "up" : "down"));
    }

    /**
     * move cursor left
     * @returns {void}
     */
    _moveLeft() {
        if (this.E.cx > 0) {
            this.E.cx--;
        } else if (this.E.cy > 0) {
            this.E.cy--;
            this.E.cx = this.E.erow[this.E.cy].length;
        }
    }

    /**
     * move cursor right
     * @param {string|boolean} row current row content
     * @returns {void}
     */
    _moveRight(row) {
        if (row &amp;&amp; this.E.cx &lt; row.length) {
            this.E.cx++;
        } else if (row !== false &amp;&amp; this.E.cx === row.length) {
            this.E.cy++;
            this.E.cx = 0;
        }
    }

    /**
     * move cursor up
     * @returns {void}
     */
    _moveUp() {
        if (this.E.cy > 0) {
            this.E.cy--;
        }
    }

    /**
     * move cursor down
     * @returns {void}
     */
    _moveDown() {
        if (this.E.cy &lt; this.E.erow.length) {
            this.E.cy++;
        }
    }

    /**
     * get left status message
     * @returns {string} left status message
     */
    _getStatusLeft() {
        const status = `${this.E.filename ? this.E.filename : "[No Name]"} - ${this.E.erow.length} lines ${this.E.dirty > 0 ? "(modified)" : ""}`;

        return status.slice(0, this.E.screencols);
    }

    /**
     * get right status message
     * @returns {string} right status message
     */
    _getStatusRight() {
        return `${parseInt((this.E.cy + 1) / this.E.erow.length * 100, 10)}% ${this.E.cy + 1}/${this.E.erow.length}`;
    }

    /**
     * drow status bar
     * @returns {void}
     */
    editorDrawStatusBar() {
        this.abuf += "\x1b[7m"; // invert the colors. (usually black -> white)
        const left = this._getStatusLeft();
        const right = this._getStatusRight();
        let len = left.length;

        this.abuf += left;
        while (len &lt; this.E.screencols) {
            if (this.E.screencols - len === right.length) {
                this.abuf += right;
                break;
            }
            this.abuf += " ";
            len++;
        }
        this.abuf += "\x1b[m"; // revert the colors. (usually white -> black)
        this.abuf += os.EOL;
    }

    /**
     * drow message bar
     * @returns {void}
     */
    editorDrawMessageBar() {
        this.abuf += "\x1b[K"; // remove all chars after the cursor position
        this.abuf += this.E.statusmsg.length > this.E.screencols ? this.E.statusmsg.slice(0, this.E.screencols) : this.E.statusmsg;
    }

    /**
     * draw welcome message
     * @returns {void}
     */
    _drawWelcomeMessage() {
        const welcome = `Kilo editor -- version ${pkg.version}`;
        let welcomelen = welcome.length;

        if (welcomelen > this.E.screencols) {
            welcomelen = this.E.screencols;
        }
        let padding = parseInt((this.E.screencols - welcomelen) / 2, 10);

        if (padding > 0) {
            this.abuf += "~";
            padding--;
        }
        while (padding-- > 0) {
            this.abuf += " ";
        }
        this.abuf += welcome.slice(0, welcomelen);
    }

    /**
     * drow file contents
     * @returns {void}
     */
    editorDrawRows() {
        for (let y = 0; y &lt; this.E.screenrows; y++) {
            const filerow = y + this.E.rowoff;

            if (filerow >= this.E.erow.length) {
                if (this.E.erow.length === 0 &amp;&amp; y === parseInt(this.E.screenrows / 3, 10)) {
                    this._drawWelcomeMessage();
                } else {
                    this.abuf += "~";
                }
            } else {
                const row = this.E.render[filerow];
                let len = row.length - this.E.coloff;

                if (len &lt; 0) {
                    len = 0;
                }
                if (len > this.E.screencols) {
                    len = this.E.screencols;
                }

                // syntax highlighting
                this.abuf += Kilo.editorUpdateSyntax(row.slice(this.E.coloff, this.E.coloff + len));
            }
            this.abuf += "\x1b[K"; // remove all chars after the cursor position
            this.abuf += os.EOL;
        }
    }

    /**
     * syntax highlighting
     * @param {string} row one row
     * @returns {string} - highlighted string
     */
    static editorUpdateSyntax(row) {
        return row
            .replace(/([0-9]+)/ug // number
                , (match, p1) => `\x1b[31m${p1}\x1b[39m`)
            .replace(/(')([^']*)(')/ug // operator
                , (match, p1, p2, p3) => `\x1b[35m${p1}${p2}${p3}\x1b[39m`) // string quote
            .replace(/(")([^"]*)(")/ug // operator
                , (match, p1, p2, p3) => `\x1b[35m${p1}${p2}${p3}\x1b[39m`) // string quote
            .replace(/(&amp;{1,2}|[-*+\\|?&lt;>;:=!])/ug // operator
                , (match, p1) => `\x1b[36m${p1}\x1b[39m`)
            .replace(/\b(typeof|try|let|const|constructor|require|this|new|undefined|static)\b/ug // keyword
                , (match, p1) => `\x1b[32m${p1}\x1b[39m`)
            .replace(/\b(break|case|catch|continue|debugger|default|delete|do|else|finally|for|function|if|while|in|instanceof|new|return|switch)\b/ug // reserved
                , (match, p1) => `\x1b[33m${p1}\x1b[39m`)
            .replace(/(\/\/.*$)/ug // comment out
                , (match, p1) => `\x1b[36m${p1}\x1b[39m`);
    }

    /**
     * main function
     * @returns {void}
     */
    main() {
        try {
            Kilo.enableRawMode();
            if (typeof this.E.filename !== "undefined") {
                this.editorOpen();
            }
            this.editorRefreshScreen();
            process.stdin.on("keypress", this.editorReadKey.bind(this));
            process.stdout.on("resize", this.editorResize.bind(this));
        } catch (e) {
            this.die(e);
        }
    }
}
if (typeof module !== "undefined") {
    module.exports = Kilo;
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="-_ul_%250A_li_initialize%2520all%2520E__li_%250A_li_this.buf%2520=%2520____li_%250A_li_set%2520timeout%2520after%25205%2520sec%2520statusmsg%2520will%2520be%2520dismissed__li_%250A__ul_.html"><ul>
<li>initialize all E</li>
<li>this.buf = ''</li>
<li>set timeout after 5 sec statusmsg will be dismissed</li>
</ul></a></li><li><a href="Kilo.html">Kilo</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a> on Sun Feb 08 2026 02:05:01 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
